(function () {
    'use strict';

    angular
        .module('demoApp.selling', [])

        .constant('PROPERTY_ICONS', ['fi-marker-blue.png', 'fi-marker-green.png', 'fi-marker-orange.png', 'fi-marker-red.png'])
    ;

}());

(function () {
    'use strict';

    angular.module('demoApp.selling')
        .controller('sellingPageController', ['$scope', 'propertyServices', sellingPageController]);

    function sellingPageController($scope, propertyServices) {
        var vm = this;

        vm.form = {};
        vm.isFiltering = false;
        vm.result = {
            items: []
        };

        vm.filter =  {
            propTypeId: '', // property type id
            propertyLocation: '', // property location
            minPrice: '',
            maxPrice: '',
            propertyId: '' // property id
        };

        vm.options = {
            propTypes: [],
            propsLocation: [],
            propsList: []
        };

        vm.clearForm = clearForm;
        vm.search = search;
        vm.onListItemClick = onListItemClick;

        function clearForm() {
            vm.filter = {};
            vm.form.$setPristine();
            vm.form.$setValidity();
            vm.form.$setUntouched();
        }

        function search() {
            vm.isFiltering = true;

            propertyServices.searchProperties(vm.filter)
                .then(function (list) {
                    if (!vm.filter.propId) {
                        vm.options.propsList = [''].concat(list.map(function (item) {
                            return {
                                id: item.id,
                                name: item.name
                            }
                        }));
                    }

                    vm.result.items = [].concat(list);
                    // TODO: group the items by province
                    // TODO: then by location
                })
                .finally(function(){
                    vm.isFiltering = false;
                });
        }

        function onListItemClick(property) {
            propertyServices.highlightProperty(property.id);
        }

        function initialize() {
            propertyServices.getPropertyTypes()
                .then(function (response) {
                    vm.options.propTypes = [''].concat(response.data);
                });

            vm.options.propsLocation = [''].concat(propertyServices.getLocations());

            $scope.$watch(function(){
                return vm.filter;
            }, function(newValue, oldValue){
                console.log(newValue, ' = ', oldValue);
            }, true);
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.home', []);

}());

(function(){
'use strict';

angular.module('demoApp.home')
    .controller('mapPageController', ['gmapServices', mapPageController]);

    function mapPageController(gmapServices) {

        var vm = this;

        function initialize () {
            gmapServices.createMap('map-canvas');
        }

        initialize();

    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .controller('layerController', [layerController]);

    function layerController() {
        var vm = this;

        vm.layers = [
            {
                label: 'Layer1',
                action: 'layerCtl.toggleLayer1()',
                selected: false
            },
            {
                label: 'Layer2',
                action: 'layerCtl.toggleLayer2()',
                selected: false
            },
            {
                label: 'LayerWithChildren1',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child1-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child1-2',
                        selected: false,
                        action: ''
                    }
                ]
            },
            {
                label: 'LayerWithChildren2',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child2-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child2-2',
                        selected: false,
                        action: ''
                    }
                ]
            }
        ];


        vm.toggleLayer1 = toggleLayer1;
        vm.toggleLayer2 = toggleLayer2;


        function toggleLayer1 () {
            if (vm.layers[0].selected) {
                console.log('turn on layer1');
            } else {
                console.log('turn off layer1');
            }
        }

        function toggleLayer2 () {
            if (vm.layers[1].selected) {
                console.log('turn on layer2');
            } else {
                console.log('turn off layer2');
            }
        }
        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('indexController', [indexController]);

    function indexController () {
        var vm = this;

        vm.initialize = initialize;

        function initialize() {
            console.log('indexController init');
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp', [
            'ui.router',
            'ngMaterial',
            'ngMessages',
            'oitozero.ngSweetAlert',
            'demoApp.home',
            'demoApp.selling'
        ])

        .constant('APP_NAME', 'Filinvest')
        .constant('BASE_URL', window.location.origin)

        //.config(function ($mdThemingProvider) {
        //    $mdThemingProvider.theme('default')
        //        .primaryPalette('indigo')
        //        .accentPalette('seaGreen');
        //})

        .config(["$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {

            $stateProvider
                // home state
                .state({
                    name: 'home',
                    url: '/',
                    templateUrl: '/partials/home/home.page.html',
                    controller: 'indexController',
                    controllerAs: 'vm'
                })

                // map page
                .state({
                    name: 'map',
                    abstract: true,
                    url: '/map',
                    templateUrl: '/partials/base/map.page.html',
                    controller: 'mapPageController'
                })

                // selling state
                .state({
                    name: 'map.selling',
                    url: '/selling',
                    templateUrl: '/partials/selling/selling.page.html',
                    controller: 'sellingPageController',
                    controllerAs: 'vm'
                })

                //.state('pageNotFoundState', {
                //    url: '/404',
                //    templateUrl: 'views/pages/404.html'
                //})
            ;

            //stateHelperProvider
            //    .state({
            //        name: 'mapPage',
            //        templateUrl: '/partials/base/map.page.html',
            //        controller: 'mapPageController',
            //        controllerAs: 'vm',
            //        children: [
            //            {
            //                name: 'selling',
            //                url: '/selling',
            //                templateUrl: '/partials/selling/selling.page.html'
            //            }
            //        ]
            //    });

            $urlRouterProvider.otherwise('/');
        }])
    ;

}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('webRequest', ['$http', webRequest]);

    function webRequest($http) {
        var service = {};

        // fix 401 errors being automatically handled by browsers
        //var BASE_URL = location.protocol + "//" + "user:pass@" + location.host + "/";
        var BASE_URL = window.location.origin;

        function buildParams(params) {
            if (params && _.isObject(params)) {
                var paramString = '';
                for (var k in params) {
                    // if (params[k]) {
                    if (!(!params[k] && params[k] !== 0)) {
                        paramString += k + '=' + params[k] + '&';
                    }
                }
                return paramString.slice(0, -1);
            }
            return '';
        }


        service.get = function (url, params) {
            return $http.get(BASE_URL + url + '?' + buildParams(params));
        };


        service.post = function (url, params) {
            return $http({
                url: BASE_URL + url,
                method: "POST",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.put = function (url, params) {
            return $http({
                url: BASE_URL + url,
                method: "PUT",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.delete = function (url) {
            return $http.delete(url);
        };


        //service.upload = function (url, fields, file) {
        //    return Upload.upload({
        //        url: BASE_URL + url,
        //        method: 'POST',
        //        fields: fields,
        //        file: file
        //    });
        //};


        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('webServices', ['webRequest', webServices]);

    function webServices(webRequest) {
        var service = {};

        service.getProperties = getProperties;
        service.getPropertyTypes = getPropertyTypes;

        function getProperties(filter) {
            return webRequest.get('/api/properties', filter);
        }

        function getPropertyTypes() {
            return webRequest.get('/api/property_types');
        }

        // function createBuilding(data) {
        //     return webRequest.post('/api/buildings', data);
        // }
        //
        // function deleteBuilding(buildingId) {
        //     var url = '/api/buildings/' + buildingId;
        //     return webRequest.delete(url);
        // }
        //
        // function updateWaypoint(waypointId, data) {
        //     var url = '/api/waypoints/' + waypointId;
        //     return webRequest.put(url, data);
        // }

        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('propertyServices', ['$q', 'webServices', 'gmapServices', 'PROPERTY_ICONS', 'infoboxServices', propertyServices]);

    function propertyServices($q, webServices, gmapServices, PROPERTY_ICONS, infoboxServices) {
        var service = {};

        service.properties = [];

        var propertyMarkers = [],
            infowindow;

        service.loadProperties = loadProperties;
        service.hidePropertyMarkers = hidePropertyMarkers;
        service.getPropertyTypes = getPropertyTypes;
        service.getLocations = getLocations;
        service.searchProperties = searchProperties;
        service.highlightProperty = highlightProperty;

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function onClickPropertyMarker() {
            console.log('onClickPropertyMarker this: ',this);

            // show infowindow
            infoboxServices.openInfobox(this.infobox, this);
        }

        function createPropertyMarker (data) {
            // var icon = '/images/markers/' + PROPERTY_ICONS[getRandomInt(0,3)];
            var icon = '/images/markers/default-marker.png';
            var marker = gmapServices.createMarker(data.latlng, icon);

            marker.propertyid = data.id;

            // create content for infowindow
            marker.infobox = infoboxServices.initInfobox(data);

            gmapServices.addListener(marker, 'click', onClickPropertyMarker.bind(marker));

            return marker;
        }

        function loadPropertyMarkers (list) {
            var foundMarker;
            list.forEach(function(item){
                if (propertyMarkers.length) {
                    foundMarker = _.findWhere(propertyMarkers, {propertyid: item.id});
                    if (foundMarker) return;
                }

                propertyMarkers.push(createPropertyMarker(item));
            })
        }

        function hidePropertyMarkers(idsToShow) {
            if (!propertyMarkers.length) return;

            if (idsToShow && idsToShow.length) {
                console.log('idsToShow: ', idsToShow);
                console.log('propertyMarkers: ', propertyMarkers);
                propertyMarkers = propertyMarkers.filter(function(marker){
                    if (idsToShow.indexOf(marker.propertyid) > -1) {
                        return marker;
                    }

                    gmapServices.hideMarker(marker);
                    marker = null;
                });
                console.log('after filtering propertyMarkers: ', propertyMarkers);
            } else {
                gmapServices.hideMarkers(propertyMarkers);
                propertyMarkers = [];
            }
        }

        function loadProperties() {
            var dfd = $q.defer();

            webServices.getProperties()
                .then(function (response) {
                    service.properties = response.data;
                    loadPropertyMarkers(response.data);
                    dfd.resolve(response.data);
                }, function(err){
                    dfd.reject(err);
                });

            return dfd.promise;
        }

        function searchProperties(filter) {
            var dfd = $q.defer();

            console.log('searchProperties filter: ', filter);

            webServices.getProperties(filter)
                .then(function (response) {
                    console.log('getProperties response: ', response);
                    hidePropertyMarkers(_.pluck(response.data, 'id'));
                    service.properties = response.data;
                    loadPropertyMarkers(response.data);
                    if (filter) {
                        gmapServices.setMapBoundsFromLatLngArray(service.properties.map(function(item){return item.latlng;}));
                    }
                    dfd.resolve(response.data);
                }, function (err) {
                    dfd.reject(err);
                });

            return dfd.promise;
        }

        function highlightProperty(propId) {
            var foundMarker = _.findWhere(propertyMarkers, {propertyid: propId});

            if (!foundMarker) return;

            gmapServices.hyperZoomToPosition(foundMarker.getPosition(), 18);
            // gmapServices.animateMarker(foundMarker);
            // show infowindow
            gmapServices.triggerEvent(foundMarker, 'click');

        }

        function getPropertyTypes() {
            return webServices.getPropertyTypes();
        }

        function getLocations() {
            return ['alabang'];
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        //var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        //var addProjectModal,
        //    projectDetailModal
        //;

        /* Service Functions */
        //service.showAddProject = showAddProject;
        //service.showProjectDetail = showProjectDetail;
        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        //function showAddProject(ev, _position) {
        //    var opts = {
        //        controller: 'addProjectController',
        //        controllerAs: 'vm',
        //        templateUrl: '/partials/modals/_add-project.tmpl.html',
        //        parent: angular.element(document.querySelector('#admin-container')),
        //        targetEvent: ev,
        //        hasBackdrop: false,
        //        locals: {position: _position},
        //        fullscreen: $mdMedia('xs'),
        //        onComplete: function (scope, element, options) {
        //            $('.md-scroll-mask').css('z-index', '-1');
        //        }
        //    };
        //
        //    return showModal(addProjectModal, opts);
        //}
        //
        //function showProjectDetail(proj) {
        //    var opts = {
        //        controller: 'projectDetailsController',
        //        controllerAs: 'vm',
        //        templateUrl: '/partials/modals/_view-project.tmpl.html',
        //        parent: angular.element(document.querySelector('#admin-container')),
        //        hasBackdrop: false,
        //        locals: {project: proj},
        //        fullscreen: $mdMedia('xs'),
        //        onComplete: function (scope, element, options) {
        //            $('.md-scroll-mask').css('z-index', '-1');
        //        }
        //    };
        //    return showModal(projectDetailModal, opts);
        //}

        function hideResolveModal(response) {
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('mainController', ['$rootScope', 'APP_NAME', '$mdSidenav', mainController]);

    function mainController($rootScope, APP_NAME, $mdSidenav) {
        var vm = this;

        var originatorEv;

        $rootScope.currentUser = {
            username: 'admin',
            role: 'admin'
        };

        $rootScope.appName = APP_NAME;

        /* Side Nav Menus */
        vm.menu = [
            {
                state: 'home',
                title: 'Home',
                icon: 'home'
            },
            {
                state: 'map.selling',
                title: 'Selling',
                icon: 'local_atm'
            },
            {
                state: 'estate-mgmt',
                title: 'Estate Mgmt',
                icon: 'account_balance'
            },
            {
                state: 'property-mgmt',
                title: 'Property Mgmt',
                icon: 'store_mall_directory'
            },
            {
                state: 'business-dev',
                title: 'Business Development',
                icon: 'work'
            },
            {
                state: 'planning-design',
                title: 'Planning and Design',
                icon: 'build'
            },
            {
                state: 'permits',
                title: 'Permits',
                icon: 'assignment'
            },
            {
                state: 'gsn',
                title: 'GSN',
                icon: 'person_pin'
            },
            {
                state: 'operations',
                title: 'Operations',
                icon: 'autorenew'
            }
        ];

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');
        vm.openRightMenu = openRightMenu;
        vm.logout = logout;


        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle();
            }
        }

        function openRightMenu($mdMenu, e) {
            originatorEv = e;
            $mdMenu.open(e);
        }

        function logout(e) {
            console.log('logout');
            originatorEv = null;
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('infoboxServices', ['gmapServices', infoboxServices]);

    function infoboxServices(gmapServices) {
        var service = {};

        var lastInfoboxOpen;

        service.initInfobox = initInfobox;
        service.createInfoboxTemplate = createInfoboxTemplate;
        service.openInfobox = openInfobox;

        function openInfobox(infobox, marker) {
            // Close last infobox open
            if (lastInfoboxOpen) lastInfoboxOpen.close();

            lastInfoboxOpen = infobox;

            infobox.open(gmapServices.map, marker);
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                // closeBoxMargin: '8px 5px',
                boxClass: 'md-whiteframe-12dp',
                // pixelOffset: new google.maps.Size(28, -95),
                pixelOffset: new google.maps.Size(30, -290), // -250 because of infobox height is 500px, half of height + -40
                // closeBoxURL: '/images/close-icon.png',
                isHidden: false,
                // pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function initInfobox(property) {
            var template = createInfoboxTemplate(property);
            return createInfoBox(template);
        }

        function createHeaderContent(property) {
            var content = '';

            content += '<img src="/images/properties/studio-city/Studio-City-Overview-bldg.jpg">';

            content += '<div class="header-right-container">';
                content += '<p class="header-right-property-name"> ' + property.name + '</p>';
                content += '<div class="header-right-property-sub">';
                    content += '<span class="header-right-average">5.0</span>';
                    content += '<span class="header-right-stars-container">';

                    for (var i=1; i<=5; i++) {
                        content += '<i class="material-icons header-right-star-' + i + ' ">&#xE8CF;</i>';
                    }

                    content += '</span>';
                    content += '<span class="header-right-reviews">22 reviews</span>';
                content += '</div>';
            content += '</div>';

            return content;
        }

        function createBodyContent(property) {
            var content = '';
            return content;
        }

        function createFooterContent(property) {
            var content = '';
            return content;
        }

        function createInfoboxTemplate(property) {
            var imageSrc = property.photos && property.photos.length
                ? property.photos[0].src
                : '/images/default-infowindow-bg.jpg';

            return '<div class="marker_info none" id="marker_info"> ' +
                    '<div class="info" id="info">' +
                        '<span class="arrow"></span>' +

                        '<section class="infobox-header"> ' + createHeaderContent(property) + '</section>' +
                        '<section class="infobox-body"> ' + createBodyContent(property) + ' </section>' +
                        '<section class="infobox-footer">' + createFooterContent(property) + '</section>' +

                '</div>' +
                '</div>';

            // return '<div class="marker_info none" id="marker_info" ' +
            //     'style="background: no-repeat linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(' + imageSrc + ')  50%/100%;"' +
            //
            //     '><div class="info" id="info">' +
            //     '<h4>' + property.name + '<span></span></h4>' +
            //     '<p>' + (property.type && property.type.name ? property.type.name : 'Not Specified') + '</p>' +
            //     '<a href="#!" class="infowindow_btn btn_view_project_detail">More info</a>' +
            //     '<span class="arrow"></span>' +
            //     '</div>' +
            //     '</div>';
        }

        return service;
    }
}());
/**
 * @name InfoBox
 * @version 1.1.12 [December 11, 2012]
 * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */

/*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint browser:true */
/*global google */

/**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */

/**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
function InfoBox(opt_opts) {

    opt_opts = opt_opts || {};

    google.maps.OverlayView.apply(this, arguments);

    // Standard options (in common with google.maps.InfoWindow):
    //
    this.content_ = opt_opts.content || "";
    this.disableAutoPan_ = opt_opts.disableAutoPan || false;
    this.maxWidth_ = opt_opts.maxWidth || 0;
    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
    this.zIndex_ = opt_opts.zIndex || null;

    // Additional options (unique to InfoBox):
    //
    this.boxClass_ = opt_opts.boxClass || "infoBox";
    this.boxStyle_ = opt_opts.boxStyle || {};
    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
    this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
    if (opt_opts.closeBoxURL === "") {
        this.closeBoxURL_ = "";
    }
    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);

    if (typeof opt_opts.visible === "undefined") {
        if (typeof opt_opts.isHidden === "undefined") {
            opt_opts.visible = true;
        } else {
            opt_opts.visible = !opt_opts.isHidden;
        }
    }
    this.isHidden_ = !opt_opts.visible;

    this.alignBottom_ = opt_opts.alignBottom || false;
    this.pane_ = opt_opts.pane || "floatPane";
    this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;

    this.div_ = null;
    this.closeListener_ = null;
    this.moveListener_ = null;
    this.contextListener_ = null;
    this.eventListeners_ = null;
    this.fixedWidthSet_ = null;
}

/* InfoBox extends OverlayView in the Google Maps API v3.
 */
InfoBox.prototype = new google.maps.OverlayView();

/**
 * Creates the DIV representing the InfoBox.
 * @private
 */
InfoBox.prototype.createInfoBoxDiv_ = function () {

    var i;
    var events;
    var bw;
    var me = this;

    // This handler prevents an event in the InfoBox from being passed on to the map.
    //
    var cancelHandler = function (e) {
        e.cancelBubble = true;
        if (e.stopPropagation) {
            e.stopPropagation();
        }
    };

    // This handler ignores the current event in the InfoBox and conditionally prevents
    // the event from being passed on to the map. It is used for the contextmenu event.
    //
    var ignoreHandler = function (e) {

        e.returnValue = false;

        if (e.preventDefault) {

            e.preventDefault();
        }

        if (!me.enableEventPropagation_) {

            cancelHandler(e);
        }
    };

    if (!this.div_) {

        this.div_ = document.createElement("div");

        this.setBoxStyle_();

        if (typeof this.content_.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
        } else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(this.content_);
        }

        // Add the InfoBox DIV to the DOM
        this.getPanes()[this.pane_].appendChild(this.div_);

        this.addClickHandler_();

        if (this.div_.style.width) {

            this.fixedWidthSet_ = true;

        } else {

            if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {

                this.div_.style.width = this.maxWidth_;
                this.div_.style.overflow = "auto";
                this.fixedWidthSet_ = true;

            } else { // The following code is needed to overcome problems with MSIE

                bw = this.getBoxWidths_();

                this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
                this.fixedWidthSet_ = false;
            }

            //this.div_.style.backgroundColor = 'red';
        }

        this.panBox_(this.disableAutoPan_);

        if (!this.enableEventPropagation_) {

            this.eventListeners_ = [];

            // Cancel event propagation.
            //
            // Note: mousemove not included (to resolve Issue 152)
            events = ["mousedown", "mouseover", "mouseout", "mouseup",
                "click", "dblclick", "touchstart", "touchend", "touchmove"];

            for (i = 0; i < events.length; i++) {

                this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
            }

            // Workaround for Google bug that causes the cursor to change to a pointer
            // when the mouse moves over a marker underneath InfoBox.
            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function (e) {
                this.style.cursor = "default";
            }));
        }

        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);

        /**
         * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
         * @name InfoBox#domready
         * @event
         */
        google.maps.event.trigger(this, "domready");
    }
};

/**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
InfoBox.prototype.getCloseBoxImg_ = function () {

    var img = "";

    if (this.closeBoxURL_ !== "") {

        img = "<img";
        img += " src='" + this.closeBoxURL_ + "'";
        img += " align=right"; // Do this because Opera chokes on style='float: right;'
        img += " style='";
        img += " position: relative;"; // Required by MSIE
        img += " cursor: pointer;";
        img += " margin: " + this.closeBoxMargin_ + ";";
        img += " z-index: 99999991;";
        img += "'>";
    }

    return img;
};

/**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
InfoBox.prototype.addClickHandler_ = function () {

    var closeBox;

    if (this.closeBoxURL_ !== "") {

        closeBox = this.div_.firstChild;
        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());

    } else {

        this.closeListener_ = null;
    }
};

/**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
InfoBox.prototype.getCloseClickHandler_ = function () {

    var me = this;

    return function (e) {

        // 1.0.3 fix: Always prevent propagation of a close box click to the map:
        e.cancelBubble = true;

        if (e.stopPropagation) {

            e.stopPropagation();
        }

        /**
         * This event is fired when the InfoBox's close box is clicked.
         * @name InfoBox#closeclick
         * @event
         */
        google.maps.event.trigger(me, "closeclick");

        me.close();
    };
};

/**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
InfoBox.prototype.panBox_ = function (disablePan) {

    var map;
    var bounds;
    var xOffset = 0, yOffset = 0;

    if (!disablePan) {

        map = this.getMap();

        if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama

            if (!map.getBounds().contains(this.position_)) {
                // Marker not in visible area of map, so set center
                // of map to the marker position first.
                map.setCenter(this.position_);
            }

            bounds = map.getBounds();

            var mapDiv = map.getDiv();
            var mapWidth = mapDiv.offsetWidth;
            var mapHeight = mapDiv.offsetHeight;
            var iwOffsetX = this.pixelOffset_.width;
            var iwOffsetY = this.pixelOffset_.height;
            var iwWidth = this.div_.offsetWidth;
            var iwHeight = this.div_.offsetHeight;
            var padX = this.infoBoxClearance_.width;
            var padY = this.infoBoxClearance_.height;
            var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);

            if (pixPosition.x < (-iwOffsetX + padX)) {
                xOffset = pixPosition.x + iwOffsetX - padX;
            } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
                xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
            }
            if (this.alignBottom_) {
                if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
                    yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
                } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
                    yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
                }
            } else {
                if (pixPosition.y < (-iwOffsetY + padY)) {
                    yOffset = pixPosition.y + iwOffsetY - padY;
                } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
                    yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
                }
            }

            if (!(xOffset === 0 && yOffset === 0)) {

                // Move the map to the shifted center.
                //
                var c = map.getCenter();
                map.panBy(xOffset, yOffset);
            }
        }
    }
};

/**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
InfoBox.prototype.setBoxStyle_ = function () {

    var i, boxStyle;

    if (this.div_) {

        // Apply style values from the style sheet defined in the boxClass parameter:
        this.div_.className = this.boxClass_;

        // Clear existing inline style values:
        this.div_.style.cssText = "";

        // Apply style values defined in the boxStyle parameter:
        boxStyle = this.boxStyle_;
        for (i in boxStyle) {

            if (boxStyle.hasOwnProperty(i)) {

                this.div_.style[i] = boxStyle[i];
            }
        }

        // Fix up opacity style for benefit of MSIE:
        //
        if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {

            this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
        }

        // Apply required styles:
        //
        this.div_.style.position = "absolute";
        this.div_.style.visibility = 'hidden';
        if (this.zIndex_ !== null) {

            this.div_.style.zIndex = this.zIndex_;
        }
    }
};

/**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
InfoBox.prototype.getBoxWidths_ = function () {

    var computedStyle;
    var bw = {top: 0, bottom: 0, left: 0, right: 0};
    var box = this.div_;

    if (document.defaultView && document.defaultView.getComputedStyle) {

        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");

        if (computedStyle) {

            // The computed styles are always in pixel units (good!)
            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
        }

    } else if (document.documentElement.currentStyle) { // MSIE

        if (box.currentStyle) {

            // The current styles may not be in pixel units, but assume they are (bad!)
            bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
            bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
            bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
            bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
        }
    }

    return bw;
};

/**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
InfoBox.prototype.onRemove = function () {

    if (this.div_) {

        this.div_.parentNode.removeChild(this.div_);
        this.div_ = null;
    }
};

/**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
InfoBox.prototype.draw = function () {

    this.createInfoBoxDiv_();

    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);

    this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";

    if (this.alignBottom_) {
        this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
    } else {
        this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
    }

    if (this.isHidden_) {

        this.div_.style.visibility = 'hidden';

    } else {

        this.div_.style.visibility = "visible";
    }
};

/**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
InfoBox.prototype.setOptions = function (opt_opts) {
    if (typeof opt_opts.boxClass !== "undefined") { // Must be first

        this.boxClass_ = opt_opts.boxClass;
        this.setBoxStyle_();
    }
    if (typeof opt_opts.boxStyle !== "undefined") { // Must be second

        this.boxStyle_ = opt_opts.boxStyle;
        this.setBoxStyle_();
    }
    if (typeof opt_opts.content !== "undefined") {

        this.setContent(opt_opts.content);
    }
    if (typeof opt_opts.disableAutoPan !== "undefined") {

        this.disableAutoPan_ = opt_opts.disableAutoPan;
    }
    if (typeof opt_opts.maxWidth !== "undefined") {

        this.maxWidth_ = opt_opts.maxWidth;
    }
    if (typeof opt_opts.pixelOffset !== "undefined") {

        this.pixelOffset_ = opt_opts.pixelOffset;
    }
    if (typeof opt_opts.alignBottom !== "undefined") {

        this.alignBottom_ = opt_opts.alignBottom;
    }
    if (typeof opt_opts.position !== "undefined") {

        this.setPosition(opt_opts.position);
    }
    if (typeof opt_opts.zIndex !== "undefined") {

        this.setZIndex(opt_opts.zIndex);
    }
    if (typeof opt_opts.closeBoxMargin !== "undefined") {

        this.closeBoxMargin_ = opt_opts.closeBoxMargin;
    }
    if (typeof opt_opts.closeBoxURL !== "undefined") {

        this.closeBoxURL_ = opt_opts.closeBoxURL;
    }
    if (typeof opt_opts.infoBoxClearance !== "undefined") {

        this.infoBoxClearance_ = opt_opts.infoBoxClearance;
    }
    if (typeof opt_opts.isHidden !== "undefined") {

        this.isHidden_ = opt_opts.isHidden;
    }
    if (typeof opt_opts.visible !== "undefined") {

        this.isHidden_ = !opt_opts.visible;
    }
    if (typeof opt_opts.enableEventPropagation !== "undefined") {

        this.enableEventPropagation_ = opt_opts.enableEventPropagation;
    }

    if (this.div_) {

        this.draw();
    }
};

/**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
InfoBox.prototype.setContent = function (content) {
    this.content_ = content;

    if (this.div_) {

        if (this.closeListener_) {

            google.maps.event.removeListener(this.closeListener_);
            this.closeListener_ = null;
        }

        // Odd code required to make things work with MSIE.
        //
        if (!this.fixedWidthSet_) {

            this.div_.style.width = "";
        }

        if (typeof content.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + content;
        } else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(content);
        }

        // Perverse code required to make things work with MSIE.
        // (Ensures the close box does, in fact, float to the right.)
        //
        if (!this.fixedWidthSet_) {
            this.div_.style.width = this.div_.offsetWidth + "px";
            if (typeof content.nodeType === "undefined") {
                this.div_.innerHTML = this.getCloseBoxImg_() + content;
            } else {
                this.div_.innerHTML = this.getCloseBoxImg_();
                this.div_.appendChild(content);
            }
        }

        this.addClickHandler_();
    }

    /**
     * This event is fired when the content of the InfoBox changes.
     * @name InfoBox#content_changed
     * @event
     */
    google.maps.event.trigger(this, "content_changed");
};

/**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
InfoBox.prototype.setPosition = function (latlng) {

    this.position_ = latlng;

    if (this.div_) {

        this.draw();
    }

    /**
     * This event is fired when the position of the InfoBox changes.
     * @name InfoBox#position_changed
     * @event
     */
    google.maps.event.trigger(this, "position_changed");
};

/**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
InfoBox.prototype.setZIndex = function (index) {

    this.zIndex_ = index;

    if (this.div_) {

        this.div_.style.zIndex = index;
    }

    /**
     * This event is fired when the zIndex of the InfoBox changes.
     * @name InfoBox#zindex_changed
     * @event
     */
    google.maps.event.trigger(this, "zindex_changed");
};

/**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
InfoBox.prototype.setVisible = function (isVisible) {

    this.isHidden_ = !isVisible;
    if (this.div_) {
        this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
    }
};

/**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
InfoBox.prototype.getContent = function () {

    return this.content_;
};

/**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
InfoBox.prototype.getPosition = function () {

    return this.position_;
};

/**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
InfoBox.prototype.getZIndex = function () {

    return this.zIndex_;
};

/**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
InfoBox.prototype.getVisible = function () {

    var isVisible;

    if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
        isVisible = false;
    } else {
        isVisible = !this.isHidden_;
    }
    return isVisible;
};

/**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.show = function () {

    this.isHidden_ = false;
    if (this.div_) {
        this.div_.style.visibility = "visible";
    }
};

/**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.hide = function () {

    this.isHidden_ = true;
    if (this.div_) {
        this.div_.style.visibility = "hidden";
    }
};

/**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
InfoBox.prototype.open = function (map, anchor) {

    var me = this;

    if (anchor) {

        this.position_ = anchor.getPosition();
        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function () {
            me.setPosition(this.getPosition());
        });
    }

    this.setMap(map);

    if (this.div_) {
        this.panBox_();
    }
};

/**
 * Removes the InfoBox from the map.
 */
InfoBox.prototype.close = function () {

    var i;

    if (this.closeListener_) {

        google.maps.event.removeListener(this.closeListener_);
        this.closeListener_ = null;
    }

    if (this.eventListeners_) {

        for (i = 0; i < this.eventListeners_.length; i++) {

            google.maps.event.removeListener(this.eventListeners_[i]);
        }
        this.eventListeners_ = null;
    }

    if (this.moveListener_) {

        google.maps.event.removeListener(this.moveListener_);
        this.moveListener_ = null;
    }

    if (this.contextListener_) {

        google.maps.event.removeListener(this.contextListener_);
        this.contextListener_ = null;
    }

    this.setMap(null);
};

(function () {
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', '$timeout', gmapServices]);

    function gmapServices($log, $q, $timeout) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(10.8774711, 123.4557964);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapBoundsFromLatLngArray = setMapBoundsFromLatLngArray;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.animateMarker = animateMarker;
        service.hyperZoomToPosition = hyperZoomToPosition;


        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            // TODO: find a way to load map without initiating again if already loaded
            //if (service.map) {
            //    service.triggerEvent(service.map, 'resize');
            //    return service.map;
            //}

            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.TOP_RIGHT
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                streetViewControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                fullscreenControl: false,
                panControl: false
            };

            $(myMapId).height($(window).height() - (42));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //service.geocoder = new google.maps.Geocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if (!(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function (infobox, index) {
                if (infobox) {
                    infobox.close();
                }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function setMapBoundsFromLatLngArray(latlngArray) {
            if (!latlngArray || latlngArray.length == 0) return;

            setMapBounds(getBoundsFromPath(latlngArray));
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if (_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else {
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if (layerName == 'meters') {
                return defaultStyle;
            } else if (layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if (layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation(latLng, polygon) {
            if (!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent(obj, event) {
            google.maps.event.trigger(obj, event);
        }

        var lastSelectedMarker;

        function animateMarker(marker, millis, animation) {
            var sec = millis || 3000;

            if (lastSelectedMarker && lastSelectedMarker instanceof google.maps.Marker) lastSelectedMarker.setAnimation(null);

            lastSelectedMarker = marker;

            var animationFunc = function () {
                marker.setAnimation(google.maps.Animation.BOUNCE || animation);

                $timeout(function () {
                    marker.setAnimation(null);
                }, sec);
            };

            animationFunc();
        }

        function hyperZoomToPosition(latLng, zoom) {
            setZoomIfGreater(zoom || 23);
            setMapCenter(latLng);
        }

        return service;
    }
}());


(function () {
    'use strict';

    function capitalizeFilter() {
        return function (t) {
            if (!t) return t;

            function e(t) {
                return t.substring(0, 1).toUpperCase() + t.substring(1)
            }

            if (-1 !== t.indexOf(" ")) {
                var r, i;
                for (t = t.toLowerCase(), r = t.split(" "), i = 0; i < r.length; i++)r[i] = e(r[i]);
                return r.toString().replace(/,/g, " ")
            }
            return t = t.toLowerCase(), e(t)
        }
    }

    angular.module('demoApp')
        .filter('capitalize', [capitalizeFilter]);

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        //service.showFilterSelectionEmpty = showFilterSelectionEmpty;
        //service.showQueryIsEmpty = showQueryIsEmpty;

        function showToast(message, position) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(2000)
            );
        }

        function showBottomLeftToast(message) {
            showToast(message, 'bottom left');
        }

        function showTopRightToast(message) {
            showToast(message, 'top right');
        }

        function showMessage(message, type) {
            SweetAlert.swal({
                title: message,
                type: type
            });
        }

        function showNoDataAvailablePrompt(entityName) {
            service.showBottomLeftToast('No ' + entityName + ' data available for this area.');
        }

        //function showFilterSelectionEmpty() {
        //    showMessage('Please select filter type.', 'warning');
        //}
        //
        //function showQueryIsEmpty() {
        //    showMessage('Please fill in search query.', 'info');
        //}

        return service;
    }
}());
(function(){
'use strict';

    var filterAddressBarDirective = function () {
        return {
            restrict: 'E',
            // replace: 'true',
            scope: {},
            templateUrl: '/partials/common/_filter_address_bar.html',
            controller: ['$scope', 'gmapServices', function filterAddressBarController($scope, gmapServices) {

                var autocomplete,
                    place;

                function placeChangeCallback() {
                    place = autocomplete.getPlace();

                    if (!place.geometry) {
                        console.log("Autocomplete's returned place contains no geometry");
                        return;
                    }

                    // If the place has a geometry, then present it on a map.
                    if (place.geometry.viewport) {
                        gmapServices.map.fitBounds(place.geometry.viewport);
                        return;
                    }

                    gmapServices.map.setCenter(place.geometry.location);
                    gmapServices.map.setZoomIfGreater(15);
                }

                function initialize() {
                    autocomplete = gmapServices.initializeAutocomplete('filter-address-input');
                    autocomplete.addListener('place_changed', placeChangeCallback);
                }

                initialize();

            }]
        };
    };

    angular.module('demoApp')
        .directive('filterAddressBar', filterAddressBarDirective);

}());