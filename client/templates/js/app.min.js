(function () {
    'use strict';

    angular
        .module('demoApp.selling', ['jkAngularCarousel'])

        .constant('PROPERTY_ICONS', ['fi-marker-blue.png', 'fi-marker-green.png', 'fi-marker-orange.png', 'fi-marker-red.png'])

        .constant('INFOBOX_CLOSED', 'INFOBOX_CLOSED')

        .constant('PROPERTY_MARKER_SELECTED', 'PROPERTY_MARKER_SELECTED')

        .constant('UNIT_MARKER_ICONS', {
            'sold': 'unit_pinlet-small-sold.png',
            'vacant': 'unit_pinlet-small-vacant.png',
            'occupied': 'unit_pinlet-small-occupied.png'
        })

        .constant('PROPERTY_THUMBNAILS', {
            header: '/images/properties/studio-city/thumbnails/Studio-City-Overview-bldg_tn.jpg',
            gallery: [
                '/images/properties/studio-city/thumbnails/interior/Studio-City-Amenities-IMG_9426_tn.jpg',
                '/images/properties/studio-city/thumbnails/interior/Studio-City-Cabana_tn.jpg',
                '/images/properties/studio-city/thumbnails/interior/Studio-City-Pool_tn.jpg'
            ],
            floorPlan: [
                '/images/properties/studio-city/thumbnails/floorplan/Arista-Calibato-ground-floor_tn.jpg',
                '/images/properties/studio-city/thumbnails/floorplan/upper-ground_tn.jpg'
            ],
            unitPlan: [
                '/images/properties/studio-city/thumbnails/floorplan/Unit-Plan_tn.jpg',
                '/images/properties/studio-city/thumbnails/floorplan/standard-studio_tn.jpg',
                '/images/properties/studio-city/thumbnails/floorplan/Studio3_tn.jpg'
            ]
        })
    ;

}());

(function () {
    'use strict';

    angular.module('demoApp.selling')
        .controller('sellingPageController', ['$rootScope', '$scope', 'propertyServices', 'INFOBOX_CLOSED', 'PROPERTY_MARKER_SELECTED', 'alertServices', 'floorplanServices', sellingPageController]);

    function sellingPageController($rootScope, $scope, propertyServices, INFOBOX_CLOSED, PROPERTY_MARKER_SELECTED, alertServices, floorplanServices) {
        var vm = this;

        vm.form = {};
        vm.isFiltering = false;
        vm.hasSearched = false;

        vm.result = {
            items: []
        };

        vm.filter =  {
            propTypeId: '', // property type id
            propertyLocation: '', // property location
            minPrice: '',
            maxPrice: '',
            propertyId: '' // property id
        };

        vm.options = {
            propTypes: [],
            propsLocation: [],
            propsList: []
        };

        vm.propertySelectedId = null;

        vm.clearForm = clearForm;
        vm.search = search;
        vm.onListItemClick = onListItemClick;

        function clearForm() {
            vm.filter = {};
            vm.result = {
                items: []
            };
            vm.propertySelectedId = null;

            propertyServices.reset(true);
            //TODO: hide all markers and infowindow
            vm.form.$setPristine();
            vm.form.$setValidity();
            vm.form.$setUntouched();
        }

        function search() {
            vm.hasSearched = true;

            vm.isFiltering = true;
            vm.propertySelectedId = null;

            propertyServices.searchProperties(vm.filter)
                .then(function (list) {
                    if (!vm.filter.propId) {
                        vm.options.propsList = [''].concat(list.map(function (item) {
                            return {
                                id: item.id,
                                name: item.name
                            }
                        }));
                    }

                    vm.result = {
                        province: 'Metro Manila Projects',
                        location: 'ALABANG',
                        projectName: 'Filinvest City',
                        items: [].concat(list)
                    };

                    // TODO: group the items by province
                    // TODO: then by location
                })
                .finally(function(){
                    vm.isFiltering = false;
                });
        }

        function onListItemClick(property) {
            vm.propertySelectedId = property.id;
            propertyServices.highlightProperty(property.id);
        }

        function onPropertyInfoboxClosed(e, params) {
            propertyServices.setMarkerToDefault(params.propertyid);
            vm.propertySelectedId = null;
            floorplanServices.clearFloorplanControl();
        }

        function cleanUp() {
            $(document).off('click', '#show-property-gallery');
            $(document).off('click', '#show-property-floorplans');
            $(document).off('click', '#show-property-details');
        }

        function showPropertyDetails(propertyId) {
            propertyServices.showPropertyDetails(propertyId)
                .finally(function(){
                    onPropertyInfoboxClosed({}, {propertyid: propertyId});
                    propertyServices.setBoundsFromProperties();
                });
        }

        function initialize() {
            propertyServices.getPropertyTypes()
                .then(function (response) {
                    vm.options.propTypes = [''].concat(response.data);
                });

            vm.options.propsLocation = [''].concat(propertyServices.getLocations());

            $scope.$watch(function(){
                return vm.filter;
            }, function(newValue, oldValue){
                console.log(newValue, ' = ', oldValue);
            }, true);

            $(document).on('click', '#show-property-gallery', function(e){
                var propId = $(this).data('propertyid');
                propertyServices.showGallery(propId);
            });

            $(document).on('click', '#show-property-floorplans', function (e) {
                var propId = $(this).data('propertyid');

                // show floorplan details on left as modal, covering the filter panel
                showPropertyDetails(propId);

                alertServices.showTopRightToast('Select Floor Plan below');

                propertyServices.initFloorplan(propId);
            });

            $(document).on('click', '#show-property-details', function (e) {
                var propId = $(this).data('propertyid');
                showPropertyDetails(propId);
            });

            $rootScope.$on(PROPERTY_MARKER_SELECTED, function(e, params){
                if (!$scope.$$phase) {
                    $scope.$apply(function(){
                        vm.propertySelectedId = params.propertyid;
                    });
                } else {
                    vm.propertySelectedId = params.propertyid;
                }

                propertyServices.highlightProperty(params.propertyid, true);

                var container = $('#selling-page .selling-result-list md-list'),
                    scrollTo = $('#selling-page .selling-result-list md-list md-list-item#property-item-' + params.propertyid);

                var scrollToValue = scrollTo.offset().top - container.offset().top + container.scrollTop();

                container.animate({
                    scrollTop: scrollToValue
                }, 1500);
            });

            $rootScope.$on(INFOBOX_CLOSED, onPropertyInfoboxClosed);

            $scope.$on('$destroy', cleanUp);
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.selling')
        .controller('propertyUnitPlanGalleryController', ['property', 'modalServices', propertyUnitPlanGalleryController]);

    function propertyUnitPlanGalleryController(property, modalServices) {
        var vm = this;

        vm.subLabel = 'Unit Plan';

        vm.carousel = {
            images: [],
            maxWidth: 700,
            maxHeight: 400,
            templateUrl: '/partials/selling/_property-gallery-item-template.html',
            currentIndex: 0
        };

        vm.close = close;

        function close() {
            modalServices.closeModal();
        }

        function initialize() {
            vm.property = property;

            vm.carousel.images = [
                {src: '/images/properties/studio-city/floorplan/Unit-Plan.jpg'},
                {src: '/images/properties/studio-city/floorplan/standard-studio.jpg'},
                {src: '/images/properties/studio-city/floorplan/Studio3.jpg'},
            ];
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.selling')
        .controller('propertyGalleryController', ['property', 'modalServices', propertyGalleryController]);

    function propertyGalleryController(property, modalServices) {
        var vm = this;

        vm.subLabel = 'Features and Amenities';

        vm.carousel = {
            images: [],
            maxWidth: 700,
            maxHeight: 400,
            templateUrl: '/partials/selling/_property-gallery-item-template.html',
            currentIndex: 0
        };

        vm.close = close;

        function close() {
            modalServices.closeModal();
        }

        function initialize() {
            console.log('propertyGalleryController init');

            vm.property = property;

            vm.carousel.images = [
                {src: '/images/properties/studio-city/interior/Studio-City-Amenities-IMG_9426.jpg'},
                {src: '/images/properties/studio-city/interior/Studio-City-Cabana.jpg'},
                {src: '/images/properties/studio-city/interior/Studio-City-Pool.jpg'},
            ];
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.selling')
        .controller('propertyFloorPlanGalleryController', ['property', 'modalServices', propertyFloorPlanGalleryController]);

    function propertyFloorPlanGalleryController(property, modalServices) {
        var vm = this;

        vm.subLabel = 'Floor Plan';

        vm.carousel = {
            images: [],
            maxWidth: 700,
            maxHeight: 400,
            templateUrl: '/partials/selling/_property-gallery-item-template.html',
            currentIndex: 0
        };

        vm.close = close;

        function close() {
            modalServices.closeModal();
        }

        function initialize() {
            vm.property = property;

            vm.carousel.images = [
                {src: '/images/properties/studio-city/floorplan/Arista-Calibato-ground-floor.jpg'},
                {src: '/images/properties/studio-city/floorplan/upper-ground.jpg'},
            ];
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.selling')
        .controller('propertyDetailsController', ['property', 'modalServices', '$timeout', 'floorplanServices', 'PROPERTY_THUMBNAILS', propertyDetailsController]);

    function propertyDetailsController(property, modalServices, $timeout, floorplanServices, PROPERTY_THUMBNAILS) {
        var vm = this;

        vm.floors = ['1', 'UG'];
        vm.units = [];

        vm.tabShown = 'main';

        vm.propertyImages = PROPERTY_THUMBNAILS;

        vm.back = back;
        vm.showGallery = showGallery;
        vm.showFloorPlanGallery = showFloorPlanGallery;
        vm.showUnitPlanGallery = showUnitPlanGallery;
        vm.goTo = goTo;
        vm.onFloorChange = onFloorChange;
        vm.onUnitSelected = onUnitSelected;

        function onUnitSelected(unit) {
            floorplanServices.triggerClickUnit(unit.id);
        }

        function onFloorChange(floor) {
            $("body #floor-container button.floor-button[data-floorname='" + floor + "']").trigger('click');

            $timeout(function(){
                var result = floorplanServices.getUnitsByFloor(floor);
                console.log('on flor hcnage result: ', result);
                vm.units = result;
            }, 500);

            //if (!result.length) return;

            //if (!$scope.$$phase) {
            //    $scope.$apply(function () {
            //        vm.units = result;
            //    });
            //} else {
            //}
        }

        function goTo(tabName) {
            vm.tabShown = tabName;
        }

        function back() {
            modalServices.closeModal();
        }

        function showGallery() {
            modalServices.showPropertyGallery(vm.property);
        }

        function showFloorPlanGallery() {
            modalServices.showFloorPlanGallery(vm.property);
        }

        function showUnitPlanGallery() {
            modalServices.showUnitPlanGallery(vm.property);
        }

        function initialize() {
            vm.property = property;

            vm.propertyImages.galleryReverse = [].concat(vm.propertyImages.gallery).reverse();

            //gmapServices.addMapListener('click', function(e){
            //    console.log('map click e: ', JSON.stringify(e.latLng.toJSON()));
            //});

            vm.selectedFloor = '1';
            $timeout(function(){
                onFloorChange(vm.selectedFloor);
            }, 1000);
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.home', []);

}());

(function(){
'use strict';

angular.module('demoApp.home')
    .controller('mapPageController', ['gmapServices', mapPageController]);

    function mapPageController(gmapServices) {

        var vm = this;

        function initialize () {
            gmapServices.createMap('map-canvas');
        }

        initialize();

    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .controller('layerController', [layerController]);

    function layerController() {
        var vm = this;

        vm.layers = [
            {
                label: 'Layer1',
                action: 'layerCtl.toggleLayer1()',
                selected: false
            },
            {
                label: 'Layer2',
                action: 'layerCtl.toggleLayer2()',
                selected: false
            },
            {
                label: 'LayerWithChildren1',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child1-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child1-2',
                        selected: false,
                        action: ''
                    }
                ]
            },
            {
                label: 'LayerWithChildren2',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child2-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child2-2',
                        selected: false,
                        action: ''
                    }
                ]
            }
        ];


        vm.toggleLayer1 = toggleLayer1;
        vm.toggleLayer2 = toggleLayer2;


        function toggleLayer1 () {
            if (vm.layers[0].selected) {
                console.log('turn on layer1');
            } else {
                console.log('turn off layer1');
            }
        }

        function toggleLayer2 () {
            if (vm.layers[1].selected) {
                console.log('turn on layer2');
            } else {
                console.log('turn off layer2');
            }
        }
        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('indexController', [indexController]);

    function indexController () {
        var vm = this;

        vm.initialize = initialize;

        function initialize() {
            console.log('indexController init');
        }

        initialize();
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp', [
            'ui.router',
            'ngMaterial',
            'ngMessages',
            'oitozero.ngSweetAlert',
            'demoApp.home',
            'demoApp.selling'
        ])

        .constant('APP_NAME', 'Filinvest')
        .constant('BASE_URL', window.location.origin)
        .constant('MARKER_BASE_URL', '/images/markers/')

        //.config(function ($mdThemingProvider) {
        //    $mdThemingProvider.theme('default')
        //        .primaryPalette('indigo')
        //        .accentPalette('seaGreen');
        //})

        .config(["$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {

            $stateProvider
                // home state
                .state({
                    name: 'home',
                    url: '/',
                    templateUrl: '/partials/home/home.page.html',
                    controller: 'indexController',
                    controllerAs: 'vm'
                })

                // map page
                .state({
                    name: 'map',
                    abstract: true,
                    url: '/map',
                    templateUrl: '/partials/base/map.page.html',
                    controller: 'mapPageController'
                })

                // selling state
                .state({
                    name: 'map.selling',
                    url: '/selling',
                    templateUrl: '/partials/selling/selling.page.html',
                    controller: 'sellingPageController',
                    controllerAs: 'vm'
                })

                //.state('pageNotFoundState', {
                //    url: '/404',
                //    templateUrl: 'views/pages/404.html'
                //})
            ;

            //stateHelperProvider
            //    .state({
            //        name: 'mapPage',
            //        templateUrl: '/partials/base/map.page.html',
            //        controller: 'mapPageController',
            //        controllerAs: 'vm',
            //        children: [
            //            {
            //                name: 'selling',
            //                url: '/selling',
            //                templateUrl: '/partials/selling/selling.page.html'
            //            }
            //        ]
            //    });

            $urlRouterProvider.otherwise('/');
        }])
    ;

}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('webRequest', ['$http', webRequest]);

    function webRequest($http) {
        var service = {};

        // fix 401 errors being automatically handled by browsers
        //var BASE_URL = location.protocol + "//" + "user:pass@" + location.host + "/";
        var BASE_URL = window.location.origin;

        function buildParams(params) {
            if (params && _.isObject(params)) {
                var paramString = '';
                for (var k in params) {
                    // if (params[k]) {
                    if (!(!params[k] && params[k] !== 0)) {
                        paramString += k + '=' + params[k] + '&';
                    }
                }
                return paramString.slice(0, -1);
            }
            return '';
        }


        service.get = function (url, params) {
            return $http.get(BASE_URL + url + '?' + buildParams(params));
        };


        service.post = function (url, params) {
            return $http({
                url: BASE_URL + url,
                method: "POST",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.put = function (url, params) {
            return $http({
                url: BASE_URL + url,
                method: "PUT",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.delete = function (url) {
            return $http.delete(url);
        };


        //service.upload = function (url, fields, file) {
        //    return Upload.upload({
        //        url: BASE_URL + url,
        //        method: 'POST',
        //        fields: fields,
        //        file: file
        //    });
        //};


        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('webServices', ['webRequest', '$q', webServices]);

    function webServices(webRequest, $q) {
        var service = {};

        service.getProperties = getProperties;
        service.getPropertyTypes = getPropertyTypes;

        service.loadFloorplan = loadFloorplan;
        service.getFloorUnits = getFloorUnits;

        function getProperties(filter) {
            return webRequest.get('/api/properties', filter);
        }

        function getPropertyTypes() {
            return webRequest.get('/api/property_types');
        }

        function loadFloorplan(propertyId) {
            var dfd = $q.defer();

            webRequest.get('/static/data/floors.json')
                .then(function(response){
                    var foundFloor = _.findWhere(response.data, {propertyid: propertyId});
                    dfd.resolve(foundFloor || response.data[0]);
                },function(err){
                    dfd.reject(err);
                });

            return dfd.promise;
        }

        function getFloorUnits(propertyId, floorName) {
            var dfd = $q.defer();

            loadFloorplan(propertyId)
                .then(function(propertyData){

                    var foundFloor = _.findWhere(propertyData.floors, {name: floorName});
                    if (foundFloor) {
                        dfd.resolve(foundFloor.rooms);
                    } else {
                        dfd.reject();
                    }

                    dfd.resolve(foundFloor || response.data[0]);
                }, function (err) {
                    dfd.reject(err);
                });

            return dfd.promise;
        }

        // function createBuilding(data) {
        //     return webRequest.post('/api/buildings', data);
        // }
        //
        // function deleteBuilding(buildingId) {
        //     var url = '/api/buildings/' + buildingId;
        //     return webRequest.delete(url);
        // }
        //
        // function updateWaypoint(waypointId, data) {
        //     var url = '/api/waypoints/' + waypointId;
        //     return webRequest.put(url, data);
        // }

        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('propertyServices', ['$q', '$rootScope', 'MARKER_BASE_URL', 'webServices', 'gmapServices', 'PROPERTY_ICONS', 'infoboxServices', 'floorplanServices', 'modalServices', 'PROPERTY_MARKER_SELECTED', propertyServices]);

    function propertyServices($q, $rootScope, MARKER_BASE_URL, webServices, gmapServices, PROPERTY_ICONS, infoboxServices, floorplanServices, modalServices, PROPERTY_MARKER_SELECTED) {
        var service = {};

        service.properties = [];

        var markerBaseUrl = MARKER_BASE_URL,
            propertyMarkers = [],
            lastSelectedMarker;

        service.loadProperties = loadProperties;
        service.hidePropertyMarkers = hidePropertyMarkers;
        service.getPropertyTypes = getPropertyTypes;
        service.getLocations = getLocations;
        service.searchProperties = searchProperties;
        service.highlightProperty = highlightProperty;
        service.setMarkerToDefault = setMarkerToDefault;
        service.initFloorplan = initFloorplan;
        service.showPropertyDetails = showPropertyDetails;
        service.reset = reset;
        service.setBoundsFromProperties = setBoundsFromProperties;
        service.showGallery = showGallery;

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function onClickPropertyMarker() {
            if (lastSelectedMarker && lastSelectedMarker.propertyid !== this.propertyid) lastSelectedMarker.setIcon(getMarkerDefaultIcon());

            lastSelectedMarker = this;

            $rootScope.$broadcast(PROPERTY_MARKER_SELECTED, {propertyid: this.propertyid});

            // show infowindow
            infoboxServices.openInfobox(this.infobox, this);
        }

        function getMarkerDefaultIcon() {
            // this is blue color
            return markerBaseUrl + PROPERTY_ICONS[0];
        }

        function getMarkerSelectedIcon() {
            // this is orange color
            return markerBaseUrl + PROPERTY_ICONS[2];
        }

        function createPropertyMarker (data) {
            // var icon = '/images/markers/' + PROPERTY_ICONS[getRandomInt(0,3)];
            //var icon = '/images/markers/default-marker.png';
            var icon = getMarkerDefaultIcon();
            var marker = gmapServices.createMarker(data.latlng, icon);

            marker.propertyid = data.id;

            // create content for infowindow
            marker.infobox = infoboxServices.initInfobox(data);

            gmapServices.addListener(marker, 'click', onClickPropertyMarker.bind(marker));

            return marker;
        }

        function loadPropertyMarkers (list) {
            var foundMarker;
            list.forEach(function(item){
                if (propertyMarkers.length) {
                    foundMarker = _.findWhere(propertyMarkers, {propertyid: item.id});
                    if (foundMarker) return;
                }

                propertyMarkers.push(createPropertyMarker(item));
            })
        }

        function hidePropertyMarkers(idsToShow) {
            if (!propertyMarkers.length) return;

            infoboxServices.closeInfobox();

            if (idsToShow && idsToShow.length) {
                console.log('idsToShow: ', idsToShow);
                console.log('propertyMarkers: ', propertyMarkers);
                propertyMarkers = propertyMarkers.filter(function(marker){
                    if (idsToShow.indexOf(marker.propertyid) > -1) {
                        return marker;
                    }

                    gmapServices.hideMarker(marker);
                    marker = null;
                });
                console.log('after filtering propertyMarkers: ', propertyMarkers);
            } else {
                gmapServices.hideMarkers(propertyMarkers);
                propertyMarkers = [];
            }
        }

        function loadProperties() {
            var dfd = $q.defer();

            webServices.getProperties()
                .then(function (response) {
                    service.properties = response.data;
                    loadPropertyMarkers(response.data);
                    dfd.resolve(response.data);
                }, function(err){
                    dfd.reject(err);
                });

            return dfd.promise;
        }

        function reset(includeMarkers) {
            if (includeMarkers) {
                hidePropertyMarkers();
                service.properties = [];
            }

            setMarkerToDefault();
            floorplanServices.clearFloorplanControl();
        }

        function setBoundsFromProperties () {
            gmapServices.setMapBoundsFromLatLngArray(service.properties.map(function (item) {
                return item.latlng;
            }));
        }

        function searchProperties(filter) {
            var dfd = $q.defer();

            // console.log('searchProperties filter: ', filter);

            webServices.getProperties(filter)
                .then(function (response) {
                    // console.log('getProperties response: ', response);

                    reset();

                    hidePropertyMarkers(_.pluck(response.data, 'id'));

                    service.properties = response.data;

                    loadPropertyMarkers(response.data);

                    if (filter) setBoundsFromProperties();

                    dfd.resolve(response.data);
                }, function (err) {
                    dfd.reject(err);
                });

            return dfd.promise;
        }

        function highlightProperty(propId, callFromOnClickMarker) {
            var foundMarker = _.findWhere(propertyMarkers, {propertyid: propId});

            if (!foundMarker) return;

            foundMarker.setIcon(getMarkerSelectedIcon());

            gmapServices.setZoomIfGreater(16);
            gmapServices.panTo(foundMarker.getPosition());
            // gmapServices.animateMarker(foundMarker);

            // show infowindow
            if (!callFromOnClickMarker) gmapServices.triggerEvent(foundMarker, 'click');

        }

        function getPropertyTypes() {
            return webServices.getPropertyTypes();
        }

        function getLocations() {
            return ['alabang'];
        }

        function setMarkerToDefault(propertyId) {
            if (!propertyId && lastSelectedMarker) {
                lastSelectedMarker.setIcon(getMarkerDefaultIcon());
                return;
            }

            var foundMarker = _.findWhere(propertyMarkers, {propertyid: propertyId});

            if (!foundMarker) return;

            foundMarker.setIcon(getMarkerDefaultIcon());
        }

        function initFloorplan(propertyId) {
            // close infobox
            infoboxServices.closeInfobox();

            // get property floorplan data in db
            floorplanServices.initFloorplan(propertyId);


            // show floorplan selection on rightside same as gmap controls
            // show 1st floor for initial floorplan
            // when floorplan selection item is clicked,
            // show its correspoding floorplan and room availability markers and show legend

            // show property details side panel
        }

        function showPropertyDetails(propertyId) {
            var foundProperty = _.findWhere(service.properties, {id: propertyId});
            if (foundProperty){
                return modalServices.showPropertyDetailsModal(foundProperty);
            }
        }

        function showGallery(propertyId) {
            var foundProperty = _.findWhere(service.properties, {id: propertyId});
            if (foundProperty) {
                return modalServices.showPropertyGallery(foundProperty);
            }
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        var modalObj;

        /* Service Functions */
        service.showPropertyDetailsModal = showPropertyDetailsModal;
        service.showPropertyGallery = showPropertyGallery;
        service.showFloorPlanGallery = showFloorPlanGallery;
        service.showUnitPlanGallery = showUnitPlanGallery;

        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        function showPropertyDetailsModal(property_) {
            var opts = {
                controller: 'propertyDetailsController',
                controllerAs: 'vm',
                templateUrl: '/partials/selling/_property-details.modal.html',
                parent: angular.element(document.querySelector('#base-container')),
                openFrom: $('body #marker_info span.arrow')[0],
                hasBackdrop: false,
                locals: {property: property_},
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };
            return showModal(modalObj, opts);
        }

        function showPropertyGallery(property_) {
            var opts = {
                controller: 'propertyGalleryController',
                controllerAs: 'vm',
                templateUrl: '/partials/selling/_property-gallery.modal.html',
                hasBackdrop: true,
                locals: {property: property_},
                multiple: true,
                fullscreen: true,
                onComplete: function (scope, element) {
                    $('.md-scroll-mask').css('z-index', '-1');
                    //setTimeout(function(){
                    //    $('#fi-gallery-modal .fi-gallery.jk-carousel').resize();
                    //
                    //    //    $(element).closest('.md-dialog-container').resize();
                    ////    $('#fi-gallery-modal').resize();
                    //}, 200);
                },
                onShowing: function (scope, element) {
                    $(element).closest('.md-dialog-container').addClass('md-dialog-container-default');
                    $('body md-dialog#property-details-modal').closest('.md-dialog-container').css('zIndex', 1);
                },
                onRemoving: function (element, removePromise) {
                    $('body md-dialog#property-details-modal').closest('.md-dialog-container').css('zIndex', 80);
                    $(element).closest('.md-dialog-container').removeClass('md-dialog-container-default');
                }
            };
            return showModal(modalObj, opts);
        }

        function showFloorPlanGallery(property_) {
            var opts = {
                controller: 'propertyFloorPlanGalleryController',
                controllerAs: 'vm',
                templateUrl: '/partials/selling/_property-gallery.modal.html',
                hasBackdrop: true,
                locals: {property: property_},
                multiple: true,
                fullscreen: true,
                onComplete: function (scope, element) {
                    $('.md-scroll-mask').css('z-index', '-1');
                },
                onShowing: function (scope, element) {
                    $('body md-dialog#property-details-modal').closest('.md-dialog-container').css('zIndex', 1);
                    $(element).closest('.md-dialog-container').addClass('md-dialog-container-default');
                },
                onRemoving: function (element, removePromise) {
                    $('body md-dialog#property-details-modal').closest('.md-dialog-container').css('zIndex', 80);
                    $(element).closest('.md-dialog-container').removeClass('md-dialog-container-default');
                }
            };
            return showModal(modalObj, opts);
        }

        function showUnitPlanGallery(property_) {
            var opts = {
                controller: 'propertyUnitPlanGalleryController',
                controllerAs: 'vm',
                templateUrl: '/partials/selling/_property-gallery.modal.html',
                hasBackdrop: true,
                locals: {property: property_},
                multiple: true,
                fullscreen: true,
                onComplete: function (scope, element) {
                    $('.md-scroll-mask').css('z-index', '-1');
                },
                onShowing: function (scope, element) {
                    $('body md-dialog#property-details-modal').closest('.md-dialog-container').css('zIndex', 1);
                    $(element).closest('.md-dialog-container').addClass('md-dialog-container-default');
                },
                onRemoving: function (element, removePromise) {
                    $('body md-dialog#property-details-modal').closest('.md-dialog-container').css('zIndex', 80);
                    $(element).closest('.md-dialog-container').removeClass('md-dialog-container-default');
                }
            };
            return showModal(modalObj, opts);
        }

        function hideResolveModal(response) {
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('mainController', ['$rootScope', 'APP_NAME', '$mdSidenav', mainController]);

    function mainController($rootScope, APP_NAME, $mdSidenav) {
        var vm = this;

        var originatorEv;

        $rootScope.currentUser = {
            username: 'admin',
            role: 'admin'
        };

        $rootScope.appName = APP_NAME;

        /* Side Nav Menus */
        vm.menu = [
            {
                state: 'home',
                title: 'Home',
                icon: 'home'
            },
            {
                state: 'map.selling',
                title: 'Selling',
                icon: 'local_atm'
            },
            {
                state: 'estate-mgmt',
                title: 'Estate Mgmt',
                icon: 'account_balance'
            },
            {
                state: 'property-mgmt',
                title: 'Property Mgmt',
                icon: 'store_mall_directory'
            },
            {
                state: 'business-dev',
                title: 'Business Development',
                icon: 'work'
            },
            {
                state: 'planning-design',
                title: 'Planning and Design',
                icon: 'build'
            },
            {
                state: 'permits',
                title: 'Permits',
                icon: 'assignment'
            },
            {
                state: 'gsn',
                title: 'GSN',
                icon: 'person_pin'
            },
            {
                state: 'operations',
                title: 'Operations',
                icon: 'autorenew'
            }
        ];

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');
        vm.openRightMenu = openRightMenu;
        vm.logout = logout;


        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle();
            }
        }

        function openRightMenu($mdMenu, e) {
            originatorEv = e;
            $mdMenu.open(e);
        }

        function logout(e) {
            console.log('logout');
            originatorEv = null;
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('infoboxServices', ['$rootScope', 'gmapServices', 'INFOBOX_CLOSED', 'PROPERTY_THUMBNAILS', infoboxServices]);

    function infoboxServices($rootScope, gmapServices, INFOBOX_CLOSED, PROPERTY_THUMBNAILS) {
        var service = {};

        var lastInfoboxOpen;

        service.initInfobox = initInfobox;
        service.createInfoboxTemplate = createInfoboxTemplate;
        service.openInfobox = openInfobox;
        service.closeInfobox = closeInfobox;

        function closeInfobox() {
            if (lastInfoboxOpen) lastInfoboxOpen.close();
        }

        function openInfobox(infobox, marker) {
            // Close last infobox open
            if (lastInfoboxOpen) lastInfoboxOpen.close();

            lastInfoboxOpen = infobox;

            infobox.open(gmapServices.map, marker);
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                // closeBoxMargin: '8px 5px',
                boxClass: 'property-infobox',
                // pixelOffset: new google.maps.Size(28, -95),
                pixelOffset: new google.maps.Size(30, -290), // -250 because of infobox height is 500px, half of height + -40
                // closeBoxURL: '/images/close-icon.png',
                isHidden: false,
                // pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function initInfobox(property) {
            var template = createInfoboxTemplate(property);
            var infobox = createInfoBox(template);

            gmapServices.addListener(infobox, 'closeclick', function(){
               console.log('infobox closeclick');
               $rootScope.$broadcast(INFOBOX_CLOSED, {propertyid: property.id});
            });

            return infobox;
        }

        function createHeaderContent(property) {
            var content = '';
            content += '<img src="'+ PROPERTY_THUMBNAILS.header +'">';
            content += '<div class="header-right-container">';
                content += '<p class="header-right-property-name"> ' + property.name + '</p>';
                content += '<div class="header-right-property-sub">';
                    content += '<span class="header-right-average">5.0</span>';
                    content += '<span class="header-right-stars-container">';

                    for (var i=1; i<=5; i++) {
                        content += '<i class="material-icons header-right-star header-right-star-' + i + ' ">star</i>';
                    }

                    content += '</span>';
                    content += '<span class="header-right-reviews">22 reviews</span>';
                content += '</div>';
            content += '</div>';
            return content;
        }

        function createBodyContent(property) {
            var content = '';
            content += '<div class="body-header">';
                content += '<h3>THE PROJECT IN A CAPSULE</h3>';
                content += '<p>Taking cue from Studio One and Studio Two, Studio City is a five-tower residential condominium laid out to accommodate open, shaded and indoor spaces for the enjoyment of young professionals.</p>';
            content += '</div>';

            content += '<div class="body-content">';
                content += '<label>Features and Amenities</label>';
                content += '<section class="body-content-images-container">';
                    content += '<div>';
                        PROPERTY_THUMBNAILS.gallery.forEach(function(src){
                            content += '<img src="'+src+'">';
                        });
                    content += '</div>';

                    content += '<div>';
                        PROPERTY_THUMBNAILS.gallery.reverse().forEach(function (src) {
                            content += '<img src="' + src + '">';
                        });
                    content += '</div>';
                content += '</section>';
            content += '</div>';
            return content;
        }

        function createButtonsContent(property) {
            var content = '';
            content += '<button data-propertyid="' + property.id + '" class="md-button box-button" id="show-property-gallery"><i class="material-icons">photo_library</i> <span>Gallery</span></button>'
            content += '<button data-propertyid="' + property.id + '" class="md-button box-button" id="show-property-floorplans"><i class="material-icons">layers</i> <span>Floorplans</span></button>'
            content += '<button data-propertyid="' + property.id + '" class="md-button box-button" id="show-property-details"><i class="material-icons">info</i> <span>More Details</span></button>'
            return content;
        }

        function createInfoboxTemplate(property) {
            return '<div class="marker_info none" id="marker_info"> ' +
                    '<div class="info" id="info">' +
                        '<span class="arrow"></span>' +

                        '<section class="infobox-header"> ' + createHeaderContent(property) + '</section>' +
                        '<section class="infobox-buttons">' + createButtonsContent(property) + '</section>' +
                        '<section class="infobox-body"> ' + createBodyContent(property) + ' </section>' +

                '</div>' +
                '</div>';
        }

        return service;
    }
}());
/**
 * @name InfoBox
 * @version 1.1.12 [December 11, 2012]
 * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */

/*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint browser:true */
/*global google */

/**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */

/**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
function InfoBox(opt_opts) {

    opt_opts = opt_opts || {};

    google.maps.OverlayView.apply(this, arguments);

    // Standard options (in common with google.maps.InfoWindow):
    //
    this.content_ = opt_opts.content || "";
    this.disableAutoPan_ = opt_opts.disableAutoPan || false;
    this.maxWidth_ = opt_opts.maxWidth || 0;
    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
    this.zIndex_ = opt_opts.zIndex || null;

    // Additional options (unique to InfoBox):
    //
    this.boxClass_ = opt_opts.boxClass || "infoBox";
    this.boxStyle_ = opt_opts.boxStyle || {};
    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
    this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
    if (opt_opts.closeBoxURL === "") {
        this.closeBoxURL_ = "";
    }
    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);

    if (typeof opt_opts.visible === "undefined") {
        if (typeof opt_opts.isHidden === "undefined") {
            opt_opts.visible = true;
        } else {
            opt_opts.visible = !opt_opts.isHidden;
        }
    }
    this.isHidden_ = !opt_opts.visible;

    this.alignBottom_ = opt_opts.alignBottom || false;
    this.pane_ = opt_opts.pane || "floatPane";
    this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;

    this.div_ = null;
    this.closeListener_ = null;
    this.moveListener_ = null;
    this.contextListener_ = null;
    this.eventListeners_ = null;
    this.fixedWidthSet_ = null;
}

/* InfoBox extends OverlayView in the Google Maps API v3.
 */
InfoBox.prototype = new google.maps.OverlayView();

/**
 * Creates the DIV representing the InfoBox.
 * @private
 */
InfoBox.prototype.createInfoBoxDiv_ = function () {

    var i;
    var events;
    var bw;
    var me = this;

    // This handler prevents an event in the InfoBox from being passed on to the map.
    //
    var cancelHandler = function (e) {
        e.cancelBubble = true;
        if (e.stopPropagation) {
            e.stopPropagation();
        }
    };

    // This handler ignores the current event in the InfoBox and conditionally prevents
    // the event from being passed on to the map. It is used for the contextmenu event.
    //
    var ignoreHandler = function (e) {

        e.returnValue = false;

        if (e.preventDefault) {

            e.preventDefault();
        }

        if (!me.enableEventPropagation_) {

            cancelHandler(e);
        }
    };

    if (!this.div_) {

        this.div_ = document.createElement("div");

        this.setBoxStyle_();

        if (typeof this.content_.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
        } else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(this.content_);
        }

        // Add the InfoBox DIV to the DOM
        this.getPanes()[this.pane_].appendChild(this.div_);

        this.addClickHandler_();

        if (this.div_.style.width) {

            this.fixedWidthSet_ = true;

        } else {

            if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {

                this.div_.style.width = this.maxWidth_;
                this.div_.style.overflow = "auto";
                this.fixedWidthSet_ = true;

            } else { // The following code is needed to overcome problems with MSIE

                bw = this.getBoxWidths_();

                this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
                this.fixedWidthSet_ = false;
            }

            //this.div_.style.backgroundColor = 'red';
        }

        this.panBox_(this.disableAutoPan_);

        if (!this.enableEventPropagation_) {

            this.eventListeners_ = [];

            // Cancel event propagation.
            //
            // Note: mousemove not included (to resolve Issue 152)
            events = ["mousedown", "mouseover", "mouseout", "mouseup",
                "click", "dblclick", "touchstart", "touchend", "touchmove"];

            for (i = 0; i < events.length; i++) {

                this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
            }

            // Workaround for Google bug that causes the cursor to change to a pointer
            // when the mouse moves over a marker underneath InfoBox.
            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function (e) {
                this.style.cursor = "default";
            }));
        }

        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);

        /**
         * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
         * @name InfoBox#domready
         * @event
         */
        google.maps.event.trigger(this, "domready");
    }
};

/**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
InfoBox.prototype.getCloseBoxImg_ = function () {

    var img = "";

    if (this.closeBoxURL_ !== "") {

        img = "<img";
        img += " src='" + this.closeBoxURL_ + "'";
        img += " align=right"; // Do this because Opera chokes on style='float: right;'
        img += " style='";
        img += " position: relative;"; // Required by MSIE
        img += " cursor: pointer;";
        img += " margin: " + this.closeBoxMargin_ + ";";
        img += " z-index: 99999991;";
        img += "'>";
    }

    return img;
};

/**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
InfoBox.prototype.addClickHandler_ = function () {

    var closeBox;

    if (this.closeBoxURL_ !== "") {

        closeBox = this.div_.firstChild;
        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());

    } else {

        this.closeListener_ = null;
    }
};

/**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
InfoBox.prototype.getCloseClickHandler_ = function () {

    var me = this;

    return function (e) {

        // 1.0.3 fix: Always prevent propagation of a close box click to the map:
        e.cancelBubble = true;

        if (e.stopPropagation) {

            e.stopPropagation();
        }

        /**
         * This event is fired when the InfoBox's close box is clicked.
         * @name InfoBox#closeclick
         * @event
         */
        google.maps.event.trigger(me, "closeclick");

        me.close();
    };
};

/**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
InfoBox.prototype.panBox_ = function (disablePan) {

    var map;
    var bounds;
    var xOffset = 0, yOffset = 0;

    if (!disablePan) {

        map = this.getMap();

        if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama

            if (!map.getBounds().contains(this.position_)) {
                // Marker not in visible area of map, so set center
                // of map to the marker position first.
                map.setCenter(this.position_);
            }

            bounds = map.getBounds();

            var mapDiv = map.getDiv();
            var mapWidth = mapDiv.offsetWidth;
            var mapHeight = mapDiv.offsetHeight;
            var iwOffsetX = this.pixelOffset_.width;
            var iwOffsetY = this.pixelOffset_.height;
            var iwWidth = this.div_.offsetWidth;
            var iwHeight = this.div_.offsetHeight;
            var padX = this.infoBoxClearance_.width;
            var padY = this.infoBoxClearance_.height;
            var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);

            if (pixPosition.x < (-iwOffsetX + padX)) {
                xOffset = pixPosition.x + iwOffsetX - padX;
            } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
                xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
            }
            if (this.alignBottom_) {
                if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
                    yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
                } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
                    yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
                }
            } else {
                if (pixPosition.y < (-iwOffsetY + padY)) {
                    yOffset = pixPosition.y + iwOffsetY - padY;
                } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
                    yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
                }
            }

            if (!(xOffset === 0 && yOffset === 0)) {

                // Move the map to the shifted center.
                //
                var c = map.getCenter();
                map.panBy(xOffset, yOffset);
            }
        }
    }
};

/**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
InfoBox.prototype.setBoxStyle_ = function () {

    var i, boxStyle;

    if (this.div_) {

        // Apply style values from the style sheet defined in the boxClass parameter:
        this.div_.className = this.boxClass_;

        // Clear existing inline style values:
        this.div_.style.cssText = "";

        // Apply style values defined in the boxStyle parameter:
        boxStyle = this.boxStyle_;
        for (i in boxStyle) {

            if (boxStyle.hasOwnProperty(i)) {

                this.div_.style[i] = boxStyle[i];
            }
        }

        // Fix up opacity style for benefit of MSIE:
        //
        if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {

            this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
        }

        // Apply required styles:
        //
        this.div_.style.position = "absolute";
        this.div_.style.visibility = 'hidden';
        if (this.zIndex_ !== null) {

            this.div_.style.zIndex = this.zIndex_;
        }
    }
};

/**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
InfoBox.prototype.getBoxWidths_ = function () {

    var computedStyle;
    var bw = {top: 0, bottom: 0, left: 0, right: 0};
    var box = this.div_;

    if (document.defaultView && document.defaultView.getComputedStyle) {

        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");

        if (computedStyle) {

            // The computed styles are always in pixel units (good!)
            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
        }

    } else if (document.documentElement.currentStyle) { // MSIE

        if (box.currentStyle) {

            // The current styles may not be in pixel units, but assume they are (bad!)
            bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
            bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
            bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
            bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
        }
    }

    return bw;
};

/**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
InfoBox.prototype.onRemove = function () {

    if (this.div_) {

        this.div_.parentNode.removeChild(this.div_);
        this.div_ = null;
    }
};

/**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
InfoBox.prototype.draw = function () {

    this.createInfoBoxDiv_();

    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);

    this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";

    if (this.alignBottom_) {
        this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
    } else {
        this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
    }

    if (this.isHidden_) {

        this.div_.style.visibility = 'hidden';

    } else {

        this.div_.style.visibility = "visible";
    }
};

/**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
InfoBox.prototype.setOptions = function (opt_opts) {
    if (typeof opt_opts.boxClass !== "undefined") { // Must be first

        this.boxClass_ = opt_opts.boxClass;
        this.setBoxStyle_();
    }
    if (typeof opt_opts.boxStyle !== "undefined") { // Must be second

        this.boxStyle_ = opt_opts.boxStyle;
        this.setBoxStyle_();
    }
    if (typeof opt_opts.content !== "undefined") {

        this.setContent(opt_opts.content);
    }
    if (typeof opt_opts.disableAutoPan !== "undefined") {

        this.disableAutoPan_ = opt_opts.disableAutoPan;
    }
    if (typeof opt_opts.maxWidth !== "undefined") {

        this.maxWidth_ = opt_opts.maxWidth;
    }
    if (typeof opt_opts.pixelOffset !== "undefined") {

        this.pixelOffset_ = opt_opts.pixelOffset;
    }
    if (typeof opt_opts.alignBottom !== "undefined") {

        this.alignBottom_ = opt_opts.alignBottom;
    }
    if (typeof opt_opts.position !== "undefined") {

        this.setPosition(opt_opts.position);
    }
    if (typeof opt_opts.zIndex !== "undefined") {

        this.setZIndex(opt_opts.zIndex);
    }
    if (typeof opt_opts.closeBoxMargin !== "undefined") {

        this.closeBoxMargin_ = opt_opts.closeBoxMargin;
    }
    if (typeof opt_opts.closeBoxURL !== "undefined") {

        this.closeBoxURL_ = opt_opts.closeBoxURL;
    }
    if (typeof opt_opts.infoBoxClearance !== "undefined") {

        this.infoBoxClearance_ = opt_opts.infoBoxClearance;
    }
    if (typeof opt_opts.isHidden !== "undefined") {

        this.isHidden_ = opt_opts.isHidden;
    }
    if (typeof opt_opts.visible !== "undefined") {

        this.isHidden_ = !opt_opts.visible;
    }
    if (typeof opt_opts.enableEventPropagation !== "undefined") {

        this.enableEventPropagation_ = opt_opts.enableEventPropagation;
    }

    if (this.div_) {

        this.draw();
    }
};

/**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
InfoBox.prototype.setContent = function (content) {
    this.content_ = content;

    if (this.div_) {

        if (this.closeListener_) {

            google.maps.event.removeListener(this.closeListener_);
            this.closeListener_ = null;
        }

        // Odd code required to make things work with MSIE.
        //
        if (!this.fixedWidthSet_) {

            this.div_.style.width = "";
        }

        if (typeof content.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + content;
        } else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(content);
        }

        // Perverse code required to make things work with MSIE.
        // (Ensures the close box does, in fact, float to the right.)
        //
        if (!this.fixedWidthSet_) {
            this.div_.style.width = this.div_.offsetWidth + "px";
            if (typeof content.nodeType === "undefined") {
                this.div_.innerHTML = this.getCloseBoxImg_() + content;
            } else {
                this.div_.innerHTML = this.getCloseBoxImg_();
                this.div_.appendChild(content);
            }
        }

        this.addClickHandler_();
    }

    /**
     * This event is fired when the content of the InfoBox changes.
     * @name InfoBox#content_changed
     * @event
     */
    google.maps.event.trigger(this, "content_changed");
};

/**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
InfoBox.prototype.setPosition = function (latlng) {

    this.position_ = latlng;

    if (this.div_) {

        this.draw();
    }

    /**
     * This event is fired when the position of the InfoBox changes.
     * @name InfoBox#position_changed
     * @event
     */
    google.maps.event.trigger(this, "position_changed");
};

/**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
InfoBox.prototype.setZIndex = function (index) {

    this.zIndex_ = index;

    if (this.div_) {

        this.div_.style.zIndex = index;
    }

    /**
     * This event is fired when the zIndex of the InfoBox changes.
     * @name InfoBox#zindex_changed
     * @event
     */
    google.maps.event.trigger(this, "zindex_changed");
};

/**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
InfoBox.prototype.setVisible = function (isVisible) {

    this.isHidden_ = !isVisible;
    if (this.div_) {
        this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
    }
};

/**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
InfoBox.prototype.getContent = function () {

    return this.content_;
};

/**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
InfoBox.prototype.getPosition = function () {

    return this.position_;
};

/**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
InfoBox.prototype.getZIndex = function () {

    return this.zIndex_;
};

/**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
InfoBox.prototype.getVisible = function () {

    var isVisible;

    if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
        isVisible = false;
    } else {
        isVisible = !this.isHidden_;
    }
    return isVisible;
};

/**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.show = function () {

    this.isHidden_ = false;
    if (this.div_) {
        this.div_.style.visibility = "visible";
    }
};

/**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.hide = function () {

    this.isHidden_ = true;
    if (this.div_) {
        this.div_.style.visibility = "hidden";
    }
};

/**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
InfoBox.prototype.open = function (map, anchor) {

    var me = this;

    if (anchor) {

        this.position_ = anchor.getPosition();
        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function () {
            me.setPosition(this.getPosition());
        });
    }

    this.setMap(map);

    if (this.div_) {
        this.panBox_();
    }
};

/**
 * Removes the InfoBox from the map.
 */
InfoBox.prototype.close = function () {

    var i;

    if (this.closeListener_) {

        google.maps.event.removeListener(this.closeListener_);
        this.closeListener_ = null;
    }

    if (this.eventListeners_) {

        for (i = 0; i < this.eventListeners_.length; i++) {

            google.maps.event.removeListener(this.eventListeners_[i]);
        }
        this.eventListeners_ = null;
    }

    if (this.moveListener_) {

        google.maps.event.removeListener(this.moveListener_);
        this.moveListener_ = null;
    }

    if (this.contextListener_) {

        google.maps.event.removeListener(this.contextListener_);
        this.contextListener_ = null;
    }

    this.setMap(null);
};

(function () {
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', '$timeout', gmapServices]);

    function gmapServices($log, $q, $timeout) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(10.8774711, 123.4557964);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapBoundsFromLatLngArray = setMapBoundsFromLatLngArray;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.animateMarker = animateMarker;
        service.hyperZoomToPosition = hyperZoomToPosition;


        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            // TODO: find a way to load map without initiating again if already loaded
            //if (service.map) {
            //    service.triggerEvent(service.map, 'resize');
            //    return service.map;
            //}

            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.TOP_RIGHT
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                streetViewControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                fullscreenControl: false,
                panControl: false
            };

            $(myMapId).height($(window).height() - (42));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //service.geocoder = new google.maps.Geocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if (!(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function (infobox, index) {
                if (infobox) {
                    infobox.close();
                }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function setMapBoundsFromLatLngArray(latlngArray) {
            if (!latlngArray || latlngArray.length == 0) return;

            setMapBounds(getBoundsFromPath(latlngArray));
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if (_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else {
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if (layerName == 'meters') {
                return defaultStyle;
            } else if (layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if (layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation(latLng, polygon) {
            if (!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent(obj, event) {
            google.maps.event.trigger(obj, event);
        }

        var lastSelectedMarker;

        function animateMarker(marker, millis, animation) {
            var sec = millis || 3000;

            if (lastSelectedMarker && lastSelectedMarker instanceof google.maps.Marker) lastSelectedMarker.setAnimation(null);

            lastSelectedMarker = marker;

            var animationFunc = function () {
                marker.setAnimation(google.maps.Animation.BOUNCE || animation);

                $timeout(function () {
                    marker.setAnimation(null);
                }, sec);
            };

            animationFunc();
        }

        function hyperZoomToPosition(latLng, zoom) {
            setZoomIfGreater(zoom || 23);
            setMapCenter(latLng);
        }

        return service;
    }
}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('floorplanServices', ['webServices', 'gmapServices', '$timeout', '$filter', 'MARKER_BASE_URL', 'UNIT_MARKER_ICONS', floorplanServices]);

    function floorplanServices (webServices, gmapServices, $timeout, $filter, MARKER_BASE_URL, UNIT_MARKER_ICONS) {
        var service = {};

        var floorData,
            floorControl;

        var floorControlIndex = 1,
            floorControlPosition = google.maps.ControlPosition.RIGHT_CENTER;

        var floorUnits = [],
            floorUnitInfowindow;

        service.initFloorplan = initFloorplan;
        service.clearFloorplanControl = clearFloorplanControl;
        service.hideFloorUnits = hideFloorUnits;
        service.getUnitsByFloor = getUnitsByFloor;
        service.triggerClickUnit = triggerClickUnit;

        function triggerClickUnit(unitId) {
            var foundUnit = _.findWhere(floorUnits, {id: unitId});
            if (foundUnit && foundUnit.marker) {
                gmapServices.triggerEvent(foundUnit.marker, 'click');
            }
        }

        function getUnitsByFloor(floor) {
            return floorUnits;
        }

        function onClickUnitMarker() {
            if (!floorUnitInfowindow) floorUnitInfowindow = gmapServices.createInfoWindow('');

            floorUnitInfowindow.setContent(this.content);

            floorUnitInfowindow.open(this.getMap(), this);
        }

        function hideFloorUnits() {
            if (floorUnits.length) {
                gmapServices.hideMarkers(
                    floorUnits.map(function(item){
                        return item.marker;
                    })
                );

                floorUnits = [];

                if (floorUnitInfowindow) {
                    floorUnitInfowindow.close();
                    floorUnitInfowindow = null;
                }
            }
        }

        function generateUnitInfowindowContent(data) {
            var content = '<div class="md-whiteframe-3dp">';
            var except = ['id', 'latlng', 'marker', 'unitplan_url'];
            for (var k in data) {
                if (except.indexOf(k) > -1) continue;
                content += '<div>' + $filter('capitalize')(k) + ': ' + '<b>' + $filter('capitalize')(data[k]) + '</b></div>';
            }
            content += '</div>';
            return content;
        }

        function createUnitMarker(data) {
            var icon = MARKER_BASE_URL + UNIT_MARKER_ICONS[data.status.toLowerCase()];
            var marker = gmapServices.createMarker(data.latlng, icon);

            marker.unitId = data.id;

            marker.content = generateUnitInfowindowContent(data);
            // create content for infowindow
            //marker.infobox = infoboxServices.initInfobox(data);

            gmapServices.addListener(marker, 'click', onClickUnitMarker.bind(marker));

            return marker;
        }

        function loadFloorUnits(propertyId, floorName) {
            if (!floorUnitInfowindow) floorUnitInfowindow = gmapServices.createInfoWindow('');


            // fetch json data
            webServices.getFloorUnits(propertyId, floorName)
                .then(function(rooms){
                   hideFloorUnits();

                    floorUnits = rooms.map(function(item){
                       item.marker = createUnitMarker(item);
                       return item;
                    });
                });
        }

        function clearFloorplanControl() {
            if (floorControl) {
                floorControl.clearFloorPlanOverlay();
                hideFloorUnits();
                gmapServices.map.controls[floorControlPosition].clear();
            }
        }

        function initFloorplanControls (data) {
            if (floorControl) gmapServices.map.controls[floorControlPosition].clear();

            var controlDiv = document.createElement('div');
            floorControl = new FloorsControl(controlDiv, gmapServices.map, data);
            controlDiv.index = floorControlIndex;
            gmapServices.map.controls[floorControlPosition].push(controlDiv);

            $('#floor-container .floor-button').on('ON_FLOOR_CLICKED', function(e, params){
                console.log('ON_FLOOR_CLICKED params: ', params);
                loadFloorUnits(params.propertyid, params.floor);
            });

            // select the first floor
            $timeout(function(){
                $('#floor-container .floor-button:last').trigger('click').trigger('focus');
            }, 500);
        }

        function initFloorplan(propertyId) {
            webServices.loadFloorplan(propertyId)
                .then(function(data){
                    floorData = data;
                    initFloorplanControls(data);

                    //$(document).on('click', 'button.floor-button', function(e){
                    //    console.log('ON FLOOR CLICKED e: ',e);
                    //    console.log('propertyid: ',$(this).data('propertyid'), ' floorname: ', $(this).data('floorname'));
                    //});
                });

        }

        return service;
    }
}());
FloorplanOverlay.prototype = new google.maps.OverlayView();

/** @constructor */
function FloorplanOverlay(bounds, image, map, floorName) {

    // Initialize all properties.
    this.bounds_ = bounds;
    this.image_ = image;
    this.map_ = map;
    this.floorName_ = floorName;

    // Define a property to hold the image's div. We'll
    // actually create this div upon receipt of the onAdd()
    // method so we'll leave it null for now.
    this.div_ = null;

    // Explicitly call setMap on this overlay.
    this.setMap(map);
}

/**
 * onAdd is called when the map's panes are ready and the overlay has been
 * added to the map.
 */
FloorplanOverlay.prototype.onAdd = function () {

    var div = document.createElement('div');
    div.id = 'floorplan-overlay';

    // Create the img element and attach it to the div.
    var img = document.createElement('img');
    img.src = this.image_;
    img.className = 'floorplan-overlay-image';

    var heading = google.maps.geometry.spherical.computeHeading(this.bounds_.getSouthWest(), this.bounds_.getNorthEast());

    // new google.maps.Marker({
    //     map:this.map_,
    //     position: this.bounds_.getNorthEast(),
    //     icon: '/images/markers/default-marker.png'
    // });
    //
    // new google.maps.Marker({
    //     map: this.map_,
    //     position: this.bounds_.getSouthWest(),
    // });

    // console.log('heading: ', heading);

    // if (this.floorName_ == 'UG') {
    //     // rotate image 90 degrees
    //     img.style.transform = 'rotate(105deg)';
    img.style.transform = 'rotate('+(heading+50)+'deg)';
    // img.style.maxWidth = '200px';
    // }


    // TODO: upon showing floorplan, show room markers, color coded by status availability

    div.appendChild(img);

    this.div_ = div;

    // Add the element to the "overlayLayer" pane.
    var panes = this.getPanes();
    panes.overlayLayer.appendChild(div);
};

FloorplanOverlay.prototype.draw = function () {

    // We use the south-west and north-east
    // coordinates of the overlay to peg it to the correct position and size.
    // To do this, we need to retrieve the projection from the overlay.
    var overlayProjection = this.getProjection();

    // Retrieve the south-west and north-east coordinates of this overlay
    // in LatLngs and convert them to pixel coordinates.
    // We'll use these coordinates to resize the div.
    var sw = overlayProjection.fromLatLngToDivPixel(this.bounds_.getSouthWest());
    var ne = overlayProjection.fromLatLngToDivPixel(this.bounds_.getNorthEast());

    // Resize the image's div to fit the indicated dimensions.
    var div = this.div_;
    div.style.left = sw.x + 'px';
    div.style.top = ne.y + 'px';
    div.style.width = (ne.x - sw.x) + 'px';
    div.style.height = (sw.y - ne.y) + 'px';
};

// The onRemove() method will be called automatically from the API if
// we ever set the overlay's map property to 'null'.
FloorplanOverlay.prototype.onRemove = function () {
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
};


/**
 * The CenterControl adds a control to the map that recenters the map on
 * Chicago.
 * This constructor takes the control DIV as an argument.
 * @constructor
 */
function FloorsControl(controlDiv, map, data) {
    var that = this;
    that.overlay_ = null;
    that.map_ = map;

    // Set CSS for the control border.
    var controlUI = document.createElement('div');
    controlUI.id = 'floor-container';
    controlUI.title = 'Click to recenter the map';
    controlDiv.appendChild(controlUI);

    data.floors.reverse().forEach(function(floor){
        // Set CSS for the control interior.
        var controlButton = document.createElement('button');
        controlButton.className = 'floor-button';
        var floorName = floor.name.length > 2
                        ? floor.name.slice(0, 2)
                        : floor.name;
        controlButton.innerHTML = floorName;

        controlButton.setAttribute('data-propertyid', data.propertyid);
        controlButton.setAttribute('data-floorname', floor.name);

        controlUI.appendChild(controlButton);

        var borderBottomDiv = document.createElement('div');
        borderBottomDiv.className = 'floor-button-border';
        controlUI.appendChild(borderBottomDiv);

        controlButton.addEventListener('click', function () {
            var bounds = new google.maps.LatLngBounds(floor.bounds.south_west, floor.bounds.north_east);
            that.loadFloorPlanOverlay(floorName, floor.image_url, bounds);
            $(controlButton).trigger('ON_FLOOR_CLICKED', {propertyid: data.propertyid, floor: floorName});
        });

        //
        // show floorplan here
     });

}

FloorsControl.prototype.loadFloorPlanOverlay = function (floorName, floorImgUrl, latLngBounds) {
    this.clearFloorPlanOverlay();

    this.overlay_ = new FloorplanOverlay(latLngBounds, floorImgUrl, this.map_, floorName);

    this.map_.fitBounds(latLngBounds);
};

FloorsControl.prototype.clearFloorPlanOverlay = function() {
  if (this.overlay_) {
      this.overlay_.setMap(null);
      this.overlay_ = null;
  }
};
(function () {
    'use strict';

    function capitalizeFilter() {
        return function (t) {
            if (!t) return t;

            function e(t) {
                return t.substring(0, 1).toUpperCase() + t.substring(1)
            }

            if (-1 !== t.indexOf(" ")) {
                var r, i;
                for (t = t.toLowerCase(), r = t.split(" "), i = 0; i < r.length; i++)r[i] = e(r[i]);
                return r.toString().replace(/,/g, " ")
            }
            return t = t.toLowerCase(), e(t)
        }
    }

    angular.module('demoApp')
        .filter('capitalize', [capitalizeFilter]);

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        //service.showFilterSelectionEmpty = showFilterSelectionEmpty;
        //service.showQueryIsEmpty = showQueryIsEmpty;

        function showToast(message, position) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(2000)
            );
        }

        function showBottomLeftToast(message) {
            showToast(message, 'bottom left');
        }

        function showTopRightToast(message) {
            showToast(message, 'top right');
        }

        function showMessage(message, type) {
            SweetAlert.swal({
                title: message,
                type: type
            });
        }

        function showNoDataAvailablePrompt(entityName) {
            service.showBottomLeftToast('No ' + entityName + ' data available for this area.');
        }

        //function showFilterSelectionEmpty() {
        //    showMessage('Please select filter type.', 'warning');
        //}
        //
        //function showQueryIsEmpty() {
        //    showMessage('Please fill in search query.', 'info');
        //}

        return service;
    }
}());
(function(){
'use strict';

    var filterAddressBarDirective = function () {
        return {
            restrict: 'E',
            // replace: 'true',
            scope: {},
            templateUrl: '/partials/common/_filter_address_bar.html',
            controller: ['$scope', 'gmapServices', function filterAddressBarController($scope, gmapServices) {

                var autocomplete,
                    place;

                function placeChangeCallback() {
                    place = autocomplete.getPlace();

                    if (!place.geometry) {
                        console.log("Autocomplete's returned place contains no geometry");
                        return;
                    }

                    // If the place has a geometry, then present it on a map.
                    if (place.geometry.viewport) {
                        gmapServices.map.fitBounds(place.geometry.viewport);
                        return;
                    }

                    gmapServices.map.setCenter(place.geometry.location);
                    gmapServices.map.setZoomIfGreater(15);
                }

                function initialize() {
                    autocomplete = gmapServices.initializeAutocomplete('filter-address-input');
                    autocomplete.addListener('place_changed', placeChangeCallback);
                }

                initialize();

            }]
        };
    };

    angular.module('demoApp')
        .directive('filterAddressBar', filterAddressBarDirective);

}());